/* waveAnlRecord.c */  
/*************************************************************************\
* Copyright (c) 2002 The University of Chicago, as Operator of Argonne
* National Laboratory.
* Copyright (c) 2002 The Regents of the University of California, as
* Operator of Los Alamos National Laboratory.
* This file is distributed subject to a Software License Agreement found
* in the file LICENSE that is included with this distribution. 
\*************************************************************************/
/* waveAnlRecord.c - Record Support Routines for waveform analysis record */
/*
 *      Original Author: John Maclean
 *      Current Author:  John Maclean
 *      Date:            6-13-00
 *
 *  The waveform analysis record is used to generate statistical information 
 *  on an array.
 *    Outputs generated by the record are: 
 *      maximum value
 *      minimum value
 *	peak to peak value
 *      mean value
 *      mean absolute deviation
 *      varience
 *      standard deviation
 *      Full Width Half Maximum 
 *
 *  Usr specified subroutines are also supported
 *
 * Modification Log:
 * -----------------
 * .00	6-13-00		jfm	Original
 * .02	12-07-00	jfm	Modified following requirements review

 */

#include <vxWorks.h>
#include <symLib.h>
#include <sysSymTbl.h>   /* for sysSymTbl*/
#include <types.h>
#include <stdioLib.h>
#include <lstLib.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>

#include "dbDefs.h"
#include "errlog.h"
#include "alarm.h"
#include "cvtTable.h"
#include "dbStaticLib.h"
#include "dbAccess.h"
#include "dbScan.h"
#include "dbEvent.h"
#include "dbFldTypes.h"
#include "recSup.h"
#include "special.h"
#include "epicsDynLink.h"
#include "menuConvert.h"
#include "menuYesNo.h"
#define GEN_SIZE_OFFSET
#include "waveAnlRecord.h"
#undef  GEN_SIZE_OFFSET 

#define WANL_REC_DEBUG 00

#define MIN_SAMPLE_SIZE 0
#define ARG_MAX 8
#define MIN_POINT_SIZE  0.000001

/* Create RSET - Record Support Entry Table*/
#define report NULL
#define initialize NULL
static long init_record();
static long process();
static long special();
#define get_value NULL
static long cvt_dbaddr();
static long get_array_info();
static long put_array_info();
static long get_units();
static long get_precision();
#define get_enum_str NULL
#define get_enum_strs NULL
#define put_enum_str NULL
static long get_graphic_double();
#define get_control_double NULL
#define get_alarm_double NULL
 
struct rset waveAnlRSET={
	RSETNUMBER,
	report,
	initialize,
	init_record,
	process,
	special,
	get_value,
	cvt_dbaddr,
	get_array_info,
	put_array_info,
	get_units,
	get_precision,
	get_enum_str,
	get_enum_strs,
	put_enum_str,
	get_graphic_double,
	get_control_double,
	get_alarm_double};

/* local functions */
static void monitor(waveAnlRecord *pwvanl);
static long readData(waveAnlRecord *pwvanl, long nElements);
static double fwhm( waveAnlRecord *pwvanl, double peak, long peakI,double base);
static double interpolate(long lowerI, 
                          double lowerBound, 
                          double upperBound,
                          double value);
static long fetch_values(struct waveAnlRecord *pwvanl);
static long findSub(waveAnlRecord *pwvanl, 
                    char          *subName, 
                    FUNCPTR       *psubAddr); 
long findIndex(waveAnlRecord *pwvanl, long val);
void findRegionInterest(waveAnlRecord *pwvanl);                    


/************************************************************/
/*                                                          */
/* Record support routines                                  */
/*                                                          */
/************************************************************/
static long init_record(void *precord,int pass)
{
  waveAnlRecord	*pwvanl = (waveAnlRecord *)precord;
  FUNCPTR       sub_addr;
  long	        status = 0;
  struct        link *plink;
  int           i;
  double        *pvalue;
  char          sub_type;
  char          temp[40];

  if (pass==1){
  
    /* Init main input link */
    pwvanl->bptr = (double *)dbCalloc(pwvanl->nelm,sizeof(double));
    if(pwvanl->bptr == NULL) {
      recGblRecordError(S_rec_outMem,(void *)pwvanl,"waveAnl: init_record");
      return(S_rec_outMem);
    }
    pwvanl->val = pwvanl->bptr;
     
    /* Now take care of X axis array */ 
    pwvanl->xptr = (double *)dbCalloc(pwvanl->nelm,sizeof(double));
    if(pwvanl->xptr == NULL) {
      recGblRecordError(S_rec_outMem,(void *)pwvanl,"waveAnl: init_record");
      return(S_rec_outMem);
    }
    /* Set up X axis */
    if(!pwvanl->xres) pwvanl->xres = 1;
    if(pwvanl->xres != pwvanl->oxrs || pwvanl->xoff != pwvanl->oxof) {
        for( i=0 ; i < pwvanl->nelm ; i++ ) {
          *(pwvanl->xptr + i) = i * pwvanl->xres + pwvanl->xoff;
        }
        pwvanl->oxrs = pwvanl->xres;
        pwvanl->oxof = pwvanl->xoff;
    }
    
    /* Set up region of interest */
    findRegionInterest(pwvanl);

    /* Init User inputs */
    plink = &pwvanl->inpa;
    pvalue = &pwvanl->a;
    for(i=0; i<ARG_MAX; i++, plink++, pvalue++) {
      if (plink->type==CONSTANT) {
        recGblInitConstantLink(plink,DBF_DOUBLE,pvalue);
      }
    }
    
    /* Find the user initialisation routine and call it if there is one */
    temp[0] = 0;
    if(strlen(pwvanl->inam)!=0) {
      temp[0] = 0;
      if(pwvanl->inam[0] != '_') {
        strcpy(temp,"_");
      }
      strcat(temp,pwvanl->inam);
   		status = symFindByNameEPICS( sysSymTbl, temp, 
                            (void *)&sub_addr, 
                            (void *) &sub_type );
      if(!status) {
        status = (*sub_addr)(pwvanl); 
      }
      else {
        recGblSetSevr(pwvanl,BAD_SUB_ALARM,INVALID_ALARM);
      }
    }
    /* Find user subroutine, if it exists */
    if( !status ) {
      if( pwvanl->snam[0] != '\0' ) {
  		  status = findSub( pwvanl, pwvanl->snam, (FUNCPTR *) &pwvanl->sadr); 
      }
      if(status) {
        recGblSetSevr(pwvanl,BAD_SUB_ALARM,INVALID_ALARM);
        pwvanl->sadr = NULL;
      }
    }
  }
    return(status);
}

static long process(void *precord)
{
  waveAnlRecord	*pwvanl = (waveAnlRecord *)precord;
  long          status = 0;
  unsigned long i;
  long          nRequest, nSamples;
  unsigned long maxI = 0;      /* index of max value */
  double        sum, ep, diff;
  
  pwvanl->pact = TRUE;
  if(!dbIsLinkConnected(&pwvanl->inp) 
    || dbGetNelements(&pwvanl->inp,&nRequest)
    || nRequest<=0) {
    recGblSetSevr(pwvanl,READ_ALARM,INVALID_ALARM);
  } 
  else {
    recGblGetTimeStamp(pwvanl);

    status = readData(pwvanl, nRequest);
    if(status) {
      return(status);
    }

    /* Execute user subroutine, if there is one, 1st call*/
    if( pwvanl->snam[0] != '\0' &&  pwvanl->sadr != NULL) {
	    pwvanl->pass = 0;
		  status = fetch_values(pwvanl);
      if(!status){
    	  status = ((FUNCPTR)(pwvanl->sadr))(pwvanl);
        if( status < 0 ) {
          recGblSetSevr(pwvanl, SOFT_ALARM, pwvanl->brsv);
        }
      }
      else {
        errlogPrintf("waveAnlRecord: link error\n");
      }
    }

    nSamples = pwvanl->enix - pwvanl->bgix + 1; 

    /* First pass, calc mean, min, max, pk to pk */
    sum = 0;
    pwvanl->min = pwvanl->max = *(pwvanl->bptr + pwvanl->bgix);
    for(i = pwvanl->bgix; i <= pwvanl->enix ; i++) {
      sum += *(pwvanl->bptr + i);
      if(pwvanl->min > *(pwvanl->bptr + i)) {
        pwvanl->min = *(pwvanl->bptr + i);
      }
      if(pwvanl->max < *(pwvanl->bptr + i)) {
        pwvanl->max = *(pwvanl->bptr + i);
        maxI = i;
      }
    }
    pwvanl->mean = sum / nSamples;
    pwvanl->pkpk = pwvanl->max - pwvanl->min;
    
    /* second pass, calc mad, var sdev */
    pwvanl->madv = 0;
    pwvanl->var = 0;
    ep = 0;
    for(i = pwvanl->bgix; i <= pwvanl->enix ; i++) {
      diff =  *(pwvanl->bptr + i) - pwvanl->mean;         
      ep += diff;
      pwvanl->madv += fabs(diff);
      pwvanl->var += diff * diff;
    }
    pwvanl->madv /= nSamples;
    pwvanl->var = (pwvanl->var - ep*ep / nSamples) / (nSamples - 1);
    pwvanl->sdev = sqrt(pwvanl->var);
    
    pwvanl->fwhm = fwhm(pwvanl, pwvanl->max, maxI, pwvanl->blof) / pwvanl->xres;

#if WANL_REC_DEBUG
    
    printf("nelm = %ld\n",pwvanl->nelm);	
    for(i=0; i < pwvanl->nelm ; i++) {
      printf("Element [%ld] = %f\txval = %f\n",i, *(pwvanl->bptr + i),
                                           *(pwvanl->xptr + i) );
    }
    printf("Min = %f, Max = %f, Mean = %f\n", pwvanl->min,pwvanl->max,
      pwvanl->mean);
    printf("mad = %f, var = %f, sdev = %f\n",pwvanl->madv ,pwvanl->var,
      pwvanl->sdev);
#endif    

  }
  
  /* Execute user subroutine, if there is one, 2nd call*/
  if( pwvanl->snam[0] != '\0' &&  pwvanl->sadr != NULL) {
	  pwvanl->pass = 1;
    status = ((FUNCPTR)(pwvanl->sadr))(pwvanl); 
    if( status < 0 ) {
      recGblSetSevr(pwvanl, SOFT_ALARM, pwvanl->brsv);
    }
  }

  /* Done the dirty work, now finish the housekeeping */
  pwvanl->udf = FALSE;
  recGblResetAlarms(pwvanl);
  monitor(pwvanl);
  /* process the forward scan link record */
  recGblFwdLink(pwvanl);
  pwvanl->pact = FALSE;
  return(status);
}

static long get_units(DBADDR *paddr, char *units)
{
  waveAnlRecord	*pwvanl=(waveAnlRecord *)paddr->precord;

  switch(dbGetFieldIndex(paddr)) {
    case waveAnlRecordVAL:
      strncpy(units,pwvanl->eguy,DB_UNITS_SIZE);
      break;
    case waveAnlRecordXPTR:
      strncpy(units,pwvanl->egux,DB_UNITS_SIZE);
      break;
  }     
  return(0);
}

static long get_precision(DBADDR *paddr, long *precision)
{
  waveAnlRecord	*pwvanl=(waveAnlRecord *)paddr->precord;

  *precision = pwvanl->prec;
  recGblGetPrec(paddr,precision);
  return(0);
}

static long get_graphic_double(DBADDR *paddr,struct dbr_grDouble *pgd)
{
  waveAnlRecord	*pwvanl=(waveAnlRecord *)paddr->precord;
  int		fieldIndex = dbGetFieldIndex(paddr);

  if ( fieldIndex == waveAnlRecordVAL
    || fieldIndex == waveAnlRecordMAX
    || fieldIndex == waveAnlRecordMIN
    || fieldIndex == waveAnlRecordMEAN
    || fieldIndex == waveAnlRecordVAR
    || fieldIndex == waveAnlRecordSDEV
    || fieldIndex == waveAnlRecordMADV
    || fieldIndex == waveAnlRecordFWHM
    || fieldIndex == waveAnlRecordPKPK
    || fieldIndex == waveAnlRecordVALA
    || fieldIndex == waveAnlRecordVALB
    || fieldIndex == waveAnlRecordVALC
    || fieldIndex == waveAnlRecordVALD
    || fieldIndex == waveAnlRecordVALE
    || fieldIndex == waveAnlRecordVALF
    || fieldIndex == waveAnlRecordVALG
    || fieldIndex == waveAnlRecordVALH
    || fieldIndex == waveAnlRecordA
    || fieldIndex == waveAnlRecordB ) {
      pgd->upper_disp_limit = pwvanl->hory;
      pgd->lower_disp_limit = pwvanl->lory;
  } else 
      recGblGetGraphicDouble(paddr,pgd);
  return(0);
}

static long cvt_dbaddr(DBADDR *paddr)
{
  waveAnlRecord	*pwvanl = (waveAnlRecord *)paddr->precord;

  switch(dbGetFieldIndex(paddr)) {
    case waveAnlRecordVAL:
      paddr->pfield = (void *)(pwvanl->val);
      paddr->no_elements = pwvanl->nelm;
      paddr->field_type = DBF_DOUBLE;
      paddr->field_size = sizeof(DBF_DOUBLE);
      paddr->dbr_field_type = DBF_DOUBLE;
/*      printf("cvt_dbaddr:waveAnlRecordVAL pfld = %ld, nel %ld\n",
          (long) pwvanl->val, pwvanl->nelm); */
      break;
    case waveAnlRecordXPTR:
      paddr->pfield = (void *)(pwvanl->xptr);
      paddr->no_elements = pwvanl->nelm;
      paddr->field_type = DBF_DOUBLE;
      paddr->field_size = sizeof(DBF_DOUBLE);
      paddr->dbr_field_type = DBF_DOUBLE;
/*      printf("cvt_dbaddr:waveAnlRecordXPTR\n");*/
      break;
    default:
      paddr->pfield = (void *)(pwvanl->bptr);
      paddr->no_elements = pwvanl->nelm;
      paddr->field_type = DBF_DOUBLE;
      printf("cvt_dbaddr:default\n");
    }     
    return(0);
}

static long get_array_info(DBADDR *paddr, long *no_elements, long *offset)
{
  waveAnlRecord	*pwvanl = (waveAnlRecord *)paddr->precord;

  switch(dbGetFieldIndex(paddr)) {
    case waveAnlRecordVAL:
      paddr->pfield = (void *)(pwvanl->val);
      *no_elements =  pwvanl->nuse;
      *offset = 0;
/*      printf("get_array_info:waveAnlRecordVAL nuse=%ld\n",pwvanl->nuse);*/
      break;
    case waveAnlRecordXPTR:
      paddr->pfield = (void *)(pwvanl->xptr);
      *no_elements =  pwvanl->nuse;
      *offset = 0;
 /*     printf("get_array_info:waveAnlRecordXPTR nuse=%ld\n",pwvanl->nuse);*/
      break;
    default:
      printf("get_array_info:default\n");
      *no_elements = 0;
      *offset = 0;
  }     
    return(0);
}

static long put_array_info(DBADDR *paddr, long nNew)
{
  waveAnlRecord	*pwvanl = (waveAnlRecord *)paddr->precord;
  
  if(nNew > pwvanl->nelm) {
    pwvanl->nuse = pwvanl->nelm;
  }
  else  {
    pwvanl->nuse = nNew;
  } 
  return(0);
}

/* Find new subroutine name if it exisists and put address in sadr  */
/* Error if routine doesn't exist																		*/
static long special(DBADDR *paddr, int after)
{
  waveAnlRecord   *pwvanl = (waveAnlRecord *)(paddr->precord);
  int		          special_type = paddr->special;
  long            status = 0;

  if(!after) return(0);

  switch(special_type) {
    case(SPC_MOD):
      switch(dbGetFieldIndex(paddr)) {
        case waveAnlRecordSNAM:
  		    status = findSub( pwvanl, pwvanl->snam, (FUNCPTR*)&pwvanl->sadr); 
          if(status) {
            pwvanl->sadr = NULL;
            recGblSetSevr(pwvanl,BAD_SUB_ALARM,INVALID_ALARM);
            recGblRecordError(S_db_BadSub,(void *)pwvanl,
                          "waveAnlRecord:special");
            status = S_db_BadSub;
          }  
          break;
        case waveAnlRecordBGRI:
        case waveAnlRecordENRI:
	case waveAnlRecordNELM:
          /* Set up region of interest */
          findRegionInterest(pwvanl);
          break;
        default: {
        recGblDbaddrError(S_db_badChoice,paddr,"waveAnl: special");
        status = S_db_badChoice;
        }
      }
      break;
    default: {
      recGblDbaddrError(S_db_badChoice,paddr,"waveAnl: special");
      status = S_db_badChoice;
    }
  }
  recGblResetAlarms(pwvanl);
  return(status);
}

/************************************************************/
/*                                                          */
/* Local routines                                           */
/*                                                          */
/************************************************************/

static void monitor(struct waveAnlRecord *pwvanl) {
  unsigned short	monitor_mask;
  double *pval; /* structure of the link field  */
  int         i;

  monitor_mask = recGblResetAlarms(pwvanl);
  monitor_mask |= (DBE_VALUE|DBE_LOG);
  /* 
  printf("waveAnl:monitor run. Mask = %d\n", monitor_mask);
  */
  if(monitor_mask) {
    db_post_events(pwvanl,pwvanl->bptr,monitor_mask);
    db_post_events(pwvanl,pwvanl->xptr,monitor_mask);
    db_post_events(pwvanl,pwvanl->val,monitor_mask);
    db_post_events(pwvanl,&pwvanl->min,monitor_mask);
    db_post_events(pwvanl,&pwvanl->max,monitor_mask);
    db_post_events(pwvanl,&pwvanl->mean,monitor_mask);
    db_post_events(pwvanl,&pwvanl->madv,monitor_mask);
    db_post_events(pwvanl,&pwvanl->var,monitor_mask);
    db_post_events(pwvanl,&pwvanl->sdev,monitor_mask);
    db_post_events(pwvanl,&pwvanl->fwhm,monitor_mask);
    db_post_events(pwvanl,&pwvanl->pkpk,monitor_mask);
    if( pwvanl->snam[0] != '\0' ) {
      /* Only need to post these if usr subrtn is executed */
      pval  = &pwvanl->vala;
      for(i=0; i<ARG_MAX; i++, pval++) {
        db_post_events(pwvanl,pval,monitor_mask);
      }
    }
  }
  return;
}

/* Get data from input links                                 */
/* Allocate a new size buffer if required                    */
static long readData(waveAnlRecord *pwvanl, long nElements) {
  long status = 0;
  int i;

  if(nElements > pwvanl->nelm) {
    nElements = pwvanl->nelm;
  }
  /* Get the merchandise in to the data buffer */
  status = dbGetLink(&pwvanl->inp, DBF_DOUBLE, pwvanl->bptr, 0, &nElements);
  if(status || nElements <= 0) {
    recGblSetSevr(pwvanl, LINK_ALARM, INVALID_ALARM);
  }
  pwvanl->nuse = pwvanl->nelm;
  
  /* Read other links */
  status=dbGetLink(&pwvanl->blol,DBR_DOUBLE, &pwvanl->blof,NULL,NULL);
  if(status) {
    recGblSetSevr(pwvanl, LINK_ALARM, INVALID_ALARM);
	}
  status=dbGetLink(&pwvanl->xrsl,DBR_DOUBLE, &pwvanl->xres,NULL,NULL);
  if(status) {
    recGblSetSevr(pwvanl, LINK_ALARM, INVALID_ALARM);
	}
  /* Make sure we don't divide by zero */
  if(pwvanl->xres == 0) {
    pwvanl->xres = 1;
  }
  status=dbGetLink(&pwvanl->xofl,DBR_DOUBLE, &pwvanl->xoff,NULL,NULL);
  if(status) {
    recGblSetSevr(pwvanl, LINK_ALARM, INVALID_ALARM);
	}
  /* recalculate X array if neccessary */
  if(pwvanl->xres != pwvanl->oxrs || pwvanl->xoff != pwvanl->oxof) {
    for( i=0 ; i < pwvanl->nelm ; i++ ) {
      *(pwvanl->xptr + i) = i * pwvanl->xres + pwvanl->xoff;
    }
    pwvanl->oxrs = pwvanl->xres;
    pwvanl->oxof = pwvanl->xoff;
  }
  return(status);
}  

/* calc fwhm in terms of array indicies, compliments of nda */
static double fwhm(waveAnlRecord *pwvanl, double peak, long peakI,double base)
{
  double hmVal;
  long hm1, hm2, i;
  double *profile;
  double fwhm1, fwhm2;
  
  if(pwvanl->thld <= 0 && pwvanl->thld >= 1) {
    pwvanl->thld = 0.5;            /* default to half max */
    recGblRecordError(S_db_badField,(void *)pwvanl,
    "waveAnl: fwhm: thld must be between 0 and 1. Replaced with default");
  }
  
  /* Calc 'half max' value. */
  hmVal = (peak - base) * pwvanl->thld + base;

  hm1 = pwvanl->bgix;
  hm2 = pwvanl->enix - 1; 
  profile = pwvanl->bptr; 
  
  /* find index at which curve passes hmVal */
  for (i=peakI; (i >= pwvanl->bgix) && (*(profile + i) > hmVal); i--) {
    hm1 = i;
  }
  for (i=peakI; (i < pwvanl->enix - 1) && (*(profile + i) > hmVal); i++) {
    hm2 = i;
  }
  
  fwhm1 = pwvanl->bgix;
  fwhm2 = pwvanl->enix - 1;   

  if(hm1 != pwvanl->bgix) {
    fwhm1 = interpolate(hm1 - 1, *(profile + hm1 - 1), *(profile + hm1), hmVal);
  }
  if(hm2 != (pwvanl->enix - 1)) {
    fwhm2 = interpolate(hm2 , *(profile + hm2), *(profile + hm2+1), hmVal);
  }

#if STAT_REC_DEBUG
  printf("pk %f, pkI %ld, base %f, hmVal %f hm1 %ld, hm2 %ld, fwhm1 %f, fwhm2 %f\n",
          peak, peakI, base, hmVal, hm1, hm2, fwhm1, fwhm2);
#endif  
  return(fwhm2 - fwhm1);
}

/* Interpolate between lowerBound and upperBound to find psuedo index value */
/* at which hm value occurs. Compliments of nda                                */
static double interpolate(long lowerI, 
                          double lowerBound, 
                          double upperBound,
                          double value)
{
  double result, range, delta;
  
  result = lowerI;
  range = upperBound - lowerBound;
  /* When no reasonable profile is present, guard against overflow/underflow */
  /* valid profile data is assumed to have at least 1 count between points */
  if (range > MIN_POINT_SIZE) {
    delta = (value - lowerBound)/range;
    result += delta;
  }
  return (result);
}

/* Get the values on INPA, INPB,... for the user subroutine    */
static long fetch_values(struct waveAnlRecord *pwvanl) {
  struct link *plink; /* structure of the link field  */
  double      *pvalue;
  int         i;
  long        status;

  plink  = &pwvanl->inpa;
  pvalue = &pwvanl->a;  
  for(i=0; i<ARG_MAX; i++, plink++, pvalue++) {
    status=dbGetLink(plink,DBR_DOUBLE, pvalue,NULL,NULL);
    if (!RTN_SUCCESS(status)) 
      return(-1);
  }
  return(0);
}

/* Find subroutine namwe given by *subName                */
/* If it exists, put subroutine address in *psubAddr      */
/* Else generate an error                                 */
static long findSub(waveAnlRecord *pwvanl, char *subName, FUNCPTR *psubAddr) {
  long    status = 0;
  char    subType;
  char    temp[40];

  if(strlen(pwvanl->snam)!=0) {
    temp[0] = 0;
    if(pwvanl->snam[0] != '_') {
      strcpy(temp,"_");
    }
    strcat(temp,pwvanl->snam);
 		status = symFindByNameEPICS( sysSymTbl, temp, 
                                (void *) psubAddr, 
                                (void *) &subType );
    if(status) {
      recGblSetSevr(pwvanl,BAD_SUB_ALARM,INVALID_ALARM);
      status = S_db_BadSub; 
    }
  }
  return(status);
}

/* find index value of an array with item value <= than         */
/* given value. Assumes array contents are in ascending order   */
long findIndex(waveAnlRecord *pwvanl, long val) {
  unsigned long i;
  long retIdx = 0;
  
  for( i=0; i < pwvanl->nelm  && *(pwvanl->xptr + i) <= val; i++) {
    retIdx = i;
/*  printf("nelm = %ld;  xptr = %f;  retIdx = %ld,  val =%ld\n", pwvanl->nelm,
       *(pwvanl->xptr + i), retIdx, val); */
  }
  return(retIdx);
}

/* Find indicies of region of interest */
/* Makes sure that bounds are legal    */
void findRegionInterest(waveAnlRecord *pwvanl) {
  long temp;

  pwvanl->bgix = findIndex(pwvanl, pwvanl->bgri);

  /* if enri is not set default to use whole array */
  if(pwvanl->enri == 0) {
    pwvanl->enix = pwvanl->nelm - 1;
  }
  else {
    pwvanl->enix = findIndex(pwvanl, pwvanl->enri);
  }
  /* beginning & end the right way round? */
  if((long)pwvanl->bgix > (long)pwvanl->enix ) {        
    temp = pwvanl->enix;
    pwvanl->enix = pwvanl->bgix;
    pwvanl->bgix = temp;
  }
/* printf("enix = %ld:  bgix = %ld\n", pwvanl->enix, pwvanl->bgix); */
  /* Beginning too close to the end of the array ? */
  if(pwvanl->nelm - pwvanl->bgix < MIN_SAMPLE_SIZE) {
    pwvanl->bgix = pwvanl->nelm - 1;
  }
/* printf("enix = %ld:  bgix = %ld\n", pwvanl->enix, pwvanl->bgix); */
  /* Region of interest big enough ? */   
  if(pwvanl->bgix - pwvanl->enix < MIN_SAMPLE_SIZE) {
    pwvanl->enix  = pwvanl->bgix;
  }
/* printf("enix = %ld:  bgix = %ld\n", pwvanl->enix, pwvanl->bgix); */
}
  
