<HTML>
<HEAD>
<TITLE>Class Documentation</TITLE>
<BODY BGCOLOR=#F0F0FF BACKGROUND="../blueback.jpg">
<FONT FACE="Comic Sans MS,Arial, Helvetica">
<BLOCKQUOTE>
<H1><A NAME=Main>Archive Class</A></H1>

The Archive class is a "smart pointer" wrapper
for an <A HREF="ArchiveI.htm#Main">ArchiveI</A>  interface pointer.
<BR>
<H2>Examples</H2>
<UL>
<LI> List all the channels in an archive (BinArchive in this case):
<PRE>
Archive         archive (new BinArchive (archive_name));
ChannelIterator channel (archive);
<BR>
archive.findFirstChannel (channel);
while (channel)
{
	cout << channel->getName() << endl;
	++ channel;
}                             
</PRE>
<LI> Find channels that match a given regular expression:
<PRE>
ChannelIterator channel(archive);
archive.findChannelByPattern ("Input[0-9]", channel);
...
</PRE>
</UL>
<BR>
See <A HREF="ChannelIterator.htm#Main">ChannelIterator</A>
about access to values.
<BR>
All methods might throw an <A HREF="ArchiveException.htm#Main">ArchiveException</A>.
<H2>Interface</H2>
<UL>
<LI>
Set <A HREF="ChannelIterator.htm#Main">ChannelIterator</A> on first channel.
Iterator allows access to next channel,
but not necessarily sorted (Hash Table).
<PRE>
bool findFirstChannel (ChannelIterator &channel);
</PRE>
<LI>
Find channel by exact name (fast since using Hash Table)
<PRE>
bool findChannelByName (const stdString &name, ChannelIterator &channel);
</PRE>
<LI>
Find first channel that matches given pattern.
If pattern is empty, findFirstChannel() will be called.
<PRE>
bool findChannelByPattern (const stdString &regular_expression, ChannelIterator &channel);
</PRE>
<LI>
Create a value suitable for the given DbrType/Count
<PRE>
ValueI *newValue (DbrType type, DbrCount count);
</PRE>
</UL>
<HR WIDTH=40% ALIGN=LEFT>
<A HREF="index.htm#Main">Index</A>
<P ALIGN=CENTER>
<FONT SIZE=1>
Created from sources with <I>MakeDoc</I> Perl script.
</FONT>
</BLOCKQUOTE>
</FONT>
</P>
</BODY>
