<HTML>
<HEAD>
<TITLE>Class Documentation</TITLE>
<BODY BGCOLOR=#F0F0FF BACKGROUND="../blueback.jpg">
<FONT FACE="Comic Sans MS,Arial, Helvetica">
<BLOCKQUOTE>
<H1><A NAME=Main>ExpandingValueIteratorI Class</A></H1>

A <A HREF="ValueIteratorI.htm#Main">ValueIteratorI</A> that expands "repeated" values
into multiple values.
(Repeated values have a severity of ARCH_REPEAT,
the status is then interpreted as a repetition count).
<BR>
Clients using this filter will never see repeat counts
but always the expanded values. 
<BR>
<H3>Example Usage</H3>
The expanding iterator requires a "base" iterator for
the archive type that you work on:
<BLOCKQUOTE><PRE>
ValueIterator   base (archive);
channel->getValueAfterTime (start, base );
</PRE></BLOCKQUOTE>
<BR>
When creating an ExpandingValueIteratorI for that base iterator,
it's usually convenient to access it via a <A HREF="ValueIterator.htm#Main">ValueIterator</A> smart wrapper
so that it behaves like an ordinary iterator:
<BLOCKQUOTE><PRE>
ValueIterator value (new ExpandingValueIteratorI (base ));
while (value)
{
	cout << *value << "\n";
	++value;
}
</PRE></BLOCKQUOTE>
<BR>
<U>TO DO:</U><BR>
Huge repeat counts are expanded. This takes forever
and the repeats may not be useful.
<H2>Interface</H2>
<UL>
<LI>
Create an ExpandingValueIteratorI based
on another <A HREF="ValueIterator.htm#Main">ValueIterator</A>.
<BR>
The base iterator has to exist for the lifetime
of the ExpandingValueIterator.
<PRE>
ExpandingValueIteratorI (ValueIterator &base);
</PRE>
<LI>
Implemented of ValueIteratorI:
<PRE>
bool isValid () const;
const ValueI * getValue () const;
bool next ();
bool prev ();
size_t determineChunk (const osiTime &until);
double getPeriod () const;     
</PRE>
<LI>
Is current value generated by expanding repeated values?
<PRE>
bool isExpanded () const;
</PRE>
</UL>
<HR WIDTH=40% ALIGN=LEFT>
<A HREF="index.htm#Main">Index</A>
<P ALIGN=CENTER>
<FONT SIZE=1>
Created from sources with <I>MakeDoc</I> Perl script.
</FONT>
</BLOCKQUOTE>
</FONT>
</P>
</BODY>
