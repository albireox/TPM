<HTML>
<HEAD>
<TITLE>Class Documentation</TITLE>
<BODY BGCOLOR=#F0F0FF BACKGROUND="../blueback.jpg">
<FONT FACE="Comic Sans MS,Arial, Helvetica">
<BLOCKQUOTE>
<H1><A NAME=Main>ValueIterator Class</A></H1>

<BR>
For easy loops a Value Iterator behaves like
a <A HREF="ValueI.htm#Main">ValueI</A>-poiter:
<BR>
<OL>
<LI> Bool-casts checks if there are values,
<LI> Poiter-reference yields Value
<LI> Increment moves to next Value
</OL>
<PRE>	
ValueIterator values(archive);
while (values)
{
	cout << *values << endl;
	sum += values->getDouble ();
	++values;
}
</PRE>
<BR>
(Implemented as "smart poiter" wrapper for <A HREF="ValueIteratorI.htm#Main">ValueIteratorI</A> iterface)
<H2>Interface</H2>
<UL>
<LI>
Obtain new, empty ValueIterator suitable for given Archive
<PRE>
ValueIterator (const class Archive &archive);
ValueIterator (ValueIteratorI *iter);
ValueIterator ();
</PRE>
<LI>
Check if iterator is at valid position
<PRE>
operator bool () const;
</PRE>
<LI>
Retrieve current <A HREF="ValueI.htm#Main">ValueI</A>
<PRE>
const ValueI * operator -> () const;
const ValueI & operator * () const;
</PRE>
<LI>
Move to next/prev Value
<PRE>
ValueIterator & operator ++ ();
ValueIterator & operator -- ();
</PRE>
<LI>
Number of "similar" values that can be read
as one chunk in a block operation:
<PRE>
size_t determineChunk (const osiTime &until);
</PRE>
<LI>
Sampling period for current values in secs.
<PRE>
double getPeriod () const;
</PRE>
</UL>
<HR WIDTH=40% ALIGN=LEFT>
<A HREF="index.htm#Main">Index</A>
<P ALIGN=CENTER>
<FONT SIZE=1>
Created from sources with <I>MakeDoc</I> Perl script.
</FONT>
</BLOCKQUOTE>
</FONT>
</P>
</BODY>
