#!/usr/local/bin/perl
#
# Read a .csv file describing the interlock bits and generate 
# an EPICS DM ADL file for each word in each interface file and an index file.
# Without a word display template file, it does an ASCII dump of sdss.csv.
#
#  Examples:
#	read-csv -t plc_word_template.adl sdss.csv
#	read-csv sdss.csv > dump.txt
#
# Note:
#	The ADL files generated by this script need to be converted to DL files
#	using the command sequence:
#
#	setup tpm
#	adls2dls -cmap $TPM_DIR/opi/medm_colors.dl <adl_files>
#
require "getopts.pl";

$adl_file = "";

if(!&Getopts('h?t:v')) {
	&syntax;
	exit 1;
}

if($opt_h) {
	&syntax;
	exit 1;
}

if($opt_t) {
	$adl_file = $opt_t;
	open(ADL, $adl_file) || die "I Cannot open file \"$adl_file\"\n";
	@adl = <ADL>;
	close(ADL);
	#print @adl;
}

if($opt_v) {
	$verbose = 1;
}
#
# Read CSV file, which is of the form:
# B3:0/0,0,FLIP_FLOP_0,Used to debounce the,low level lighting,switch and latch the,light on.,,0,,,0
#
while(<>) {
	s/\s+$//;	# Remove ^M
	$line = $_;

	($what, $scope, $name, $d1, $d2, $d3, $d4, $d5) = split(/,/, $_);
	if($name eq "") {
		next;
	}
	if($scope != 0) {
		warn "Expected global scope (\"0\") but saw $scope for $name\n"
	}

	#$name =~ tr/A-Z/a-z/;
#
#	Concatenate all non-blank description fields, separated by spaces
#
	$descrip = "";
	foreach $d ($d1, $d2, $d3, $d4, $d5) {
		$d =~ s/"//g;		# Remove "
		if($d ne "") {
			if($descrip) {
				$descrip .= " $d";
			} else {
				$descrip .= "$d";
			}
		}
	}
#
#	Store each variable in the corresponding array
#
	push @names, $name;
	$descrips{$name} = $descrip;
	$whats{$name} = $what;

	$_ = $what;
#
#	Extract hardware information from the "what" string for
#	B0..., I0... and O0...
#
	if(/^([FNSTU]|PFILE)/) {
		next;
	} elsif(m#^(B[0-9]+):([0-9]+)(/([0-9]+))?#) {
		$plcfile = $1; $word = $2; $bit = $4;
	} elsif(m#^([IO]):([0-9]+)\.([0-9]+)(/([0-9]+))?#) {
		$plcfile = "$1$2"; $word = $3; $bit = $5;
	} else {
		die "$line";
	}
#
#	Store each variable in the corresponding array
#
	$plcfiles{$name} = $plcfile;
	$words{$name} = $word;
	if($bit ne "") {
		$bits{"$plcfile:$word:$name"} = $bit;
	}
}
#
# Generate requested output
#
if ($adl_file) {
#
# Find the entries that are just documention of bit field words
#
	foreach $name (@names) {
		$what = $whats{$name};
		if($what !~ /^[BIO]/) {
			next;
		}

		$plcfile = $plcfiles{$name};
		$word = $words{$name};
		$bit = $bits{"$plcfile:$word:$name"};

		if($bit eq "") {
	#
	# Is this a name for a word that also has individual bits named?
	# Look for input lines that define bits within this word; if there
	# are any it's a name for the entire word and we discard it
	#
	# We save the results of the, rather slow, grep in bitfield_and_word
	#
			if(!(exists $bitfield_and_word{"$plcfile:$word"})) {
				$bitfield_and_word{"$plcfile:$word"} =
				grep(/$plcfile:$word:/, keys(%bits));
			}

			if($bitfield_and_word{"$plcfile:$word"}) {
				if($verbose) {
					warn "$plcfile:$word $name is a bitfield description field\n";
				}
				next;
			}
		}
	#
	# Generate oplcfiles
	#
		$oplcfiles{"${plcfile}_L${word}"}++;
		eval "\$${plcfile}_L${word}{$bit} = '$name';";
	}
#
# OK! finally generate the desired code
#
	dm_index_file ("begin");
	dm_related_display ("init");

	$lplcfile = "";
	foreach $os (sort by_plcfile_name keys %oplcfiles) {
		if ($verbose) { print "$os\n"; }

		if($os =~ /^([BIO][0-9]+)_L([0-9]+)/) {
			$plcfile = $1; $word = $2;
		} else {
			next;
		}
		@adl2 = @adl;
		$channel = sprintf ("tpm_AB%s_%02d", $plcfile, $word);

		if ($plcfile ne $lplcfile) {
			if ($lplcfile ne "") { dm_related_display ("end", "$lplcfile"); }
			dm_related_display ("begin");
		}
		$lplcfile = $plcfile;

		dm_related_display ("$word", "$channel.dl", "");

		foreach (@adl2) { $_ =~ s/CHANNEL/$channel/; }

		foreach $bit (sort by_num_forwards (keys %$os)) {
			$name = $$os{$bit};
			$desc = sprintf ("DESC%02d", $bit);
			#print "$bit\t$desc\t$name\n";
			foreach (@adl2) { $_ =~ s/$desc/$name/; }
		}
		foreach (@adl2) { $_ =~ s.DESC[0-1][0-9].NOT MBBI/O.; }	# non-bits
		#print @adl2;
		open(FILE, ">$channel.adl") || die "I cannot open file \"$channel.adl\"\n";
		print FILE @adl2;
		close FILE;

	}
	dm_related_display ("end", "$lplcfile");
	dm_index_file ("end");
} else {			# simple ascii dump
	foreach $name (@names) {
		print "$whats{$name}|$name|$descrips{$name}\n";
	}
}

###############################################################################

sub by_num_backwards
{
	return $b <=> $a;
}

sub by_num_forwards
{
	return $a <=> $b;
}

sub by_plcfile_name
{
	local($a0, $a1, $a2, $b0, $b1, $b2);
	$a =~ /^(.)([0-9]+)_.([0-9]+)/; $a1 = $1; $a2 = $2; $a3 = $3;
	$b =~ /^(.)([0-9]+)_.([0-9]+)/; $b1 = $1; $b2 = $2; $b3 = $3;

	if(($a1 cmp $b1) != 0) {
		return $a1 cmp $b1;
	} else {
		if(($a2 <=> $b2) != 0) {
			return $a2 <=> $b2;
		} else {
			return $a3 <=> $b3;
		}
	}
}

sub dm_index_file
{
	local ($_) = @_;
	if ($verbose) { print "Entering dm_index_file, args: @_\n"; }

	if (/^begin/) {
		open(INDEX, ">plc_file_index.adl") || die "I cannot open file \"plc_file_index.adl\"\n";
		print INDEX <<"EOT";
file {
	name="index.dl"
}
display {
	magic="305419896"
	majv="2"
	mnrv="4"
	ndyng="0"
	npc="1"
	nstr="27"
	ndynamic="0"
	nplot="0"
	nrd="0"
	nes="0"
	nkd="0"
	npd="0"
	npo="0"
	object {
		x="0"
		y="0"
		width="100"
		height="560"
	}
	clr="0"
	bclr="1"
	nwords_dspy="248"
	nwords_sta="16"
	nwords_cmap="0"
	nwords_crules="0"
	odyng="248"
	osta="232"
	odynamic="248"
	oplot="248"
	ord="248"
	oes="248"
	okd="248"
	opd="248"
	opo="248"
	opc="68"
	ostr="72"
	ocmap="232"
	ocrules="232"
	style="solid"
	fill="outline"
	width="0"
	clrmod="static"
	vismod="static"
	precision="255"
	clrrule="alarm"
	pv=""
	cmap="medm_colors.dl"
	pixwid="1152"
	pixht="900"
	mmwid="390"
	mmht="305"
}
"<<basic attribute>>" {
	attr {
		clr="14"
		style="solid"
		fill="outline"
		width="3"
	}
}
"text" {
	object {
		x="5"
		y="10"
		width="90"
		height="15"
		groupid="0"
	}
	textix="PLC Files"
	align="horiz. centered"
}
EOT

	} elsif (/^end/) {
		print INDEX <<"EOT";
"kill display" {
	object {
		x="10"
		y="525"
		width="80"
		height="25"
		groupid="0"
	}
	label="EXIT"
	clr="14"
	bclr="20"
	decorate="outward"
}
EOT
		close (INDEX);
	}
}

sub dm_related_display
{
	local ($_) = @_;
	if ($verbose) { print "Entering dm_related_display, args: @_\n"; }

	if (/^init/) {
		$y=40;

	} elsif (/^begin/) {
		$display = 0;

		print INDEX <<"EOT";
"related display" {
    object {
        x="20"
        y="$y"
        width="60"
        height="25"
        groupid="0"
    }
    selfkill="off"
EOT

	} elsif (/^end/) {
		local ($args, $name) = @_;
		print INDEX <<"EOT";
	clr="14"
	bclr="2"
	menu_title="$name"
	decorate="outward"
}
EOT
		$y += 25;

	} else {
		local ($label, $name, $args) = @_;
		print INDEX "\tdisplay[$display] {\n\t\tlabel=\"$label\"\n\t\tname=\"$name\"\n\t\targs=\"$args\"\n\t}\n";
		$display++;
	}
}

sub syntax
{
	print <<"EOT";
Extract documentation and/or bit offsets from a .csv file, as produced
from the PLC by John Anderson
Usage:
	read-csv [options] file
Options:
	-h	Print this message
	-t file	Generate ADL files for EPICS DM using ADL template <file>
	-v	Be chatty
EOT
}
